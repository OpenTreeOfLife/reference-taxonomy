# Metrics for taxonomy writeup.

import sys, os, json

def format_report(taxo_path, metrics_path):
    print """# Results

The assembly method described above yields the reference taxonomy that
is used by the Open Tree of Life project.  The taxonomy itself, the
details of how the assembly method unrolls to generate the taxonomy,
and the degree to which the taxonomy meets the goals set out for it
are all of interest in assessing how, and how well, the method works.
We will address each of these three aspects of
the method in turn."""
    print
    with open(metrics_path, 'r') as infile:
        metrics = json.load(infile)
        metrics['branching_factor'] = \
           "%.2f" % ((metrics['node_count']*1.0)/metrics['internal_node_count'])
        report_part(metrics,
                    """## Characterizing the overall assembly product

Following are some general metrics on the reference taxonomy.
""",
                    metrics_label_info, False)
    with open(os.path.join(taxo_path, 'alignment_summary.json'), 'r') as infile:
        summary = json.load(infile)
        (h_table, h_count) = prepare_table(summary, heuristic_label_info, True)
        summary['by-heuristic'] = h_count
        report_part(summary,
                    """## Fate of source nodes in alignment phase

As OTT is assembled, the alignment procedure examines every source
node, either choosing an alignment target for it in the workspace, or
leaving it unaligned.  The following table categorizes source nodes 
according to how they are processed in the alignment phase.""",
                    alignment_label_info,
                    True)
        show_table(h_table, """## Use of heuristics

The following is a breakdown on the use frequency of the various alignment heuristics, pooled across all source
taxonomies.  The counts include only reductions in the candidate set from more than 
one candidate to a single candidate.""")

    with open(os.path.join(taxo_path, 'merge_summary.json'), 'r') as infile:
        report_part(json.load(infile),
                    """## Fate of source nodes in merge phase

The merge phase examines every source node, copying unaligned source
nodes into the workspace when possible.  The following table
categorizes the fate of each source node during the merge phase.""",
                    merge_label_info,
                    True)

# summary is the report json as generated by smasher

def report_part(summary, description, label_info, totalize):
    (table, total) = prepare_table(summary, label_info, totalize)
    show_table(table, description)

def show_table(table, description):
    print description
    print
    # show_table_ascii(table)
    show_table_html(table)

def show_table_ascii(table):
    for (count, label) in table:
        print fmt % (count, label)
    print

def prepare_table(summary, label_info, totalize):
    for key in summary:
        if not key in all_keys:
            print >>sys.stderr, 'unrecognized key: %s' % key
    data = join(summary, label_info)
    table = [(count, label) for (rank, label, count) in
             sorted(data, key=lambda((r,l,c)): r)]
    total = 0
    if totalize:
        total = include_total(table)
    return (table, total)

def include_total(table):
    total = table_total(table)
    table.append((total, 'Total'))
    return total

def table_total(table):
    return sum([count for (count, label) in table])

def join(summary, label_info):
    data = []
    for key in label_info:
        count = summary.get(key, 0)
        (rank, label) = label_info[key]
        if label == None: label = key
        data.append((rank, label, count))
    return data

def show_table_html(table):
    print '<table border="1">'
    for row in table:
        do_row(row)
    print '</table>'
    print

# cf. sources_table.py
def do_row(cells):
    print '  <tr>'
    atts = ' align="right"'
    for val in cells:
        cell(val, atts)
        atts = ''
    print '  </tr>'

def cell(val, atts):
    print '    <td %s>' % atts
    print '   ', val
    print '    </td>'


metrics_label_info = {
    'node_count':
     (0, """Number of taxon records (nodes)."""),
    'synonym_count':
     (2, """Number of synonym records."""),
    'tip_count':
     (4, """Number of tips."""),
    'internal_node_count':
     (3, """Number of internal (non-tip) nodes."""),
    'species':
     (5, """Number of nodes with a known rank of 'species'."""),
    'binomials':
     (6, """Number of nodes whose name-string has the form of a Linnaean binomial <em>Genus epithet</em>.  
This measurement serves a proxy for the number of described species in the taxonomy, as
opposed to temporary names (e.g. <em>bacterium 7A7</em>) assigned by NCBI."""),
    'homonym_count':
     (7, """Number of homonym name-strings, i.e. those belonging to more than one node."""),
    'species_homonym_count':
     (8, """Number of homonym name-strings where the nodes have species rank."""),
    'genus_homonym_count':
     (9, """Number of homonym name-strings where the nodes have genus rank."""),
    'max_depth':
     (10, """Maximum nesting depth of any node in the taxonomy."""),
    'max_children':
    (11, """Maximum number of children for any node in the taxonomy."""),
    'branching_factor':
    (20, """Branching factor (average number of children per internal node)."""),

    'absorbed':
     (70, """Record-keeping placeholders for source taxa that were absorbed into a larger taxon."""),
    'incertae_sedis_count':
     (72, """Number of nodes marked <em>incertae sedis</em> or equivalent."""),
    'extinct_count':
     (74, """Number of nodes annotated as being for an extinct taxon."""),
    'infraspecific_count':
     (76, """Number of nodes below the rank of species (e.g. subspecies, variety)."""),
    'barren':
     (78, """Number of nodes above the rank of species that subtend no node of rank species."""),
}

alignment_label_info = {
    "same/curated":
    (02, """Alignment particularly established by a curator, usually to
            repair a mistake made by automatic alignment."""),
    "same/by-division-name":
    (04, """Aligned to separation taxonomy, to establish source taxonomy nodes for the separation taxa."""),
    "by-heuristic":
    (10, """A choice was made between two or more candidates using heuristics (for breakdown see below)."""),
    "confirmed":
    (30, """There was only a single candidate, and it was confirmed
            by a 'yes' answer from one of the heuristics."""),
    "by elimination":
    (32, """There was only a single candidate, and it was not confirmed by any
heuristic (the match involved a synonym)."""),
    "ambiguous tip":
    (36, """The heuristics were unable to choose from among multiple
candidates; no alignment is recorded for the source node, which is a tip."""),
    "ambiguous internal":
    (38, """The heuristics were unable to choose from among multiple
candidates; no alignment is recorded for the source node, which is internal."""),
    "rejected":
    (39, """Every candidate was rejected by some heuristic."""),
    "not-same/disjoint":
    (40, """Internal nodes separated after application of heuristics.  
[This is a big kludge, and possibly not needed.  Could be taken care of during alignment if overlap test were based on tip alignment instead of names.]"""),
    "none":
    (43, """The source node was not aligned to any workspace node;
there were no candidates at all for this source taxon."""),
}

# names to agree with those in method-details.md

heuristic_label_info = {
    "disjoint divisions":    (10, 'Separation'),
    "disparate ranks":       (11, "Disparate ranks"),
    "by lineage":            (12, 'Lineage'),
    "overlapping membership":(14, 'Overlap'),
    "same division":         (16, 'Proximity'),
    "by name":               (18, 'Same name-string'),
}

merge_label_info = {
    "mapped/tip":
    (66, """Source node (a tip) is aligned to a workspace node.  No action, except that the 
source's extinctness flag, if any, is copied to the workspace node."""), #was aligned/tip
    "mapped/internal":
    (68, """Similarly, internal node"""), #was aligned/internal
    "new/tip":
    (70, """Source tip not aligned, so a new tip is created in the workspace."""),
    "new/polysemy":
    (72, """Similarly but there is already another node with this name-string in the workspace."""),
    "new/graft":
    (74, 'New internal node, part of graft'),
    "new/refinement":
    (76, 'Source node inserted into the hierarchy above one workspace node and below another'),
    "reject/merged":
    (80, 'Source node absorbed into larger workspace taxon'),
    "reject/inconsistent":
    (82, 'Source node absorbed into larger taxon due to conflict [fix me]'),
    "reject/wayward":
    (84, 'Source parent does not descend from nearest aligned [fix me]'),
}

all_keys = {}
for i in [metrics_label_info, heuristic_label_info, alignment_label_info, merge_label_info]:
    for key in i:
        all_keys[key] = True

def sort_key(label):
    return label_info.get(label, label)

if __name__ == '__main__':
    format_report(sys.argv[1], sys.argv[2])
