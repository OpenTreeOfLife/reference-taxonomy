# Metrics for taxonomy writeup.

import sys, os, json, csv

# summaries_path is the directory containing the JSON and CSV summary files
#   (alignment_summary.json and 3 or so others)
# metrics_path is where to put the markdown

def format_report(summaries_path):
    print """# Results

The assembly method described above yields the reference taxonomy that
is used by the Open Tree of Life project.  The taxonomy itself, the
details of how the assembly method unrolls to generate the taxonomy,
and the degree to which the taxonomy meets the goals set out for it
are all of interest in assessing how, and how well, the method works.
We will address each of these three aspects of
the method in turn."""
    print

    # General metrics on the taxomony

    mpath = os.path.join(summaries_path, 'taxonomy_summary.json')
    with open(mpath, 'r') as infile:
        metrics = json.load(infile)
        metrics['branching_factor'] = \
           "%.2f" % ((metrics['node_count']*1.0)/metrics['internal_node_count'])
        report_part(metrics,
                    """## Characterizing the overall assembly product

Following are some general metrics on the reference taxonomy.
""",
                    metrics_label_info,
                    None)

    # Fate under alignment

    apath = os.path.join(summaries_path, 'alignment_summary.json')
    with open(apath, 'r') as infile:
        summary = json.load(infile)
        (h_table, h_count) = prepare_table(summary, heuristic_label_info, None)
        h_total = table_total(h_table)
        print >>sys.stderr, '| total choices made:', h_total
        summary['by-heuristic'] = h_total
        report_part(summary,
                    """## Fate of source nodes in alignment phase

As OTT is assembled, the alignment procedure examines every source
node, either choosing an alignment target for it in the workspace, or
leaving it unaligned.  The following table categorizes source nodes 
according to how they are processed in the alignment phase.""",
                    alignment_label_info,
                    "Total number of source nodes (other than separation taxonomy).")
        print

        # Use of heuristics in choice-making

        show_table(h_table, """## Use of heuristics

The following is a breakdown on the use frequency of the various alignment heuristics, pooled across all source
taxonomies.  The counts include only reductions in the candidate set from more than 
one candidate to a single candidate.""")

    # Fate under merge

    gpath = os.path.join(summaries_path, 'merge_summary.json')
    with open(gpath, 'r') as infile:
        s = json.load(infile)
        report_part(s, """## Fate of source nodes in merge phase

The merge phase examines every source node, copying unaligned source
nodes into the workspace when possible.  The following table
categorizes the fate of each source node during the merge phase.""",
                    merge_label_info,
                    "Total number of source nodes.")

    # Contributions from the various sources

    cpath = os.path.join(summaries_path, 'contributions_summary.csv')
    with open(cpath, 'r') as infile:
        rows = []
        for row in csv.reader(infile):
            rows.append(row)
        show_table(rows,
                   """## Source contributions breakdown""")

    print """
Key:

* source = name of source taxonomy
* total = total number of nodes in source
* copied = total number of nodes originating from this source (copied)
* aligned = number of source nodes aligned and copied
* absorbed = number of source nodes absorbed
* conflict = number of inconsistent source nodes
"""
    print


# summary is the report json as generated by smasher

def report_part(summary, description, label_info, total_description):
    (table, total) = prepare_table(summary, label_info, total_description)
    show_table(table, description)

# returns (list of (rank, label, count), total)

def prepare_table(summary, label_info, total_description):
    for key in summary:
        if not key in all_keys:
            print >>sys.stderr, '** unrecognized key: %s %s' % (key, summary[key])
    data = join(summary, label_info)
    table = [(count, label) for (rank, label, count) in
             sorted(data, key=lambda((r,l,c)): r)]
    total = 0
    if total_description != None:
        return include_total(table, total_description)
    return (table, total)

def include_total(table, total_description):
    total = table_total(table)
    table = [(total, total_description)] + table
    return (table, total)

def table_total(table):
    return sum([count for (count, label) in table])

def join(summary, label_info):
    data = []
    for key in label_info:
        count = summary.get(key, 0)
        (rank, label) = label_info[key]
        if label == None: label = key
        data.append((rank, label, count))
    return data

def show_table(table, description):
    print description
    print
    # show_table_ascii(table)
    show_table_html(table)
    show_table_csv(table)

def show_table_csv(table):
    print
    print '```'
    writer = csv.writer(sys.stdout, lineterminator='  \n')
    for row in table:
        if not isinstance(row[0], int) or row[0] > 0:
            writer.writerow(row)
    print '```'

def show_table_ascii(table):
    for (count, label) in table:
        print fmt % (count, label)
    print

def show_table_html(table):
    print '<table border="1">'
    for row in table:
        if not isinstance(row[0], int) or row[0] > 0:
            do_row(row)
    print '</table>'
    print

# cf. sources_table.py
def do_row(cells):
    print '  <tr>'
    atts = ' align="right"'
    for val in cells:
        cell(val, atts)
        atts = ''
    print '  </tr>'

def cell(val, atts):
    print '    <td %s>' % atts
    print '   ', val
    print '    </td>'


metrics_label_info = {
    'node_count':
     (0, """Number of taxon records (nodes)."""),
    'synonym_count':
     (2, """Number of synonym records."""),
    'tip_count':
     (4, """Number of tips."""),
    'internal_node_count':
     (3, """Number of internal (non-tip) nodes."""),
    'species':
     (5, """Number of nodes with a known rank of 'species'."""),
    'binomials':
     (6, """Number of nodes whose name-string has the form of a Linnaean binomial <em>Genus epithet</em>.  
This measurement serves a proxy for the number of described species in the taxonomy, as
opposed to ad hoc names (e.g. <em>bacterium 7A7</em>) assigned by NCBI."""),
    'homonym_count':
     (7, """Number of homonym name-strings, i.e. those belonging to more than one node."""),
    'species_homonym_count':
     (8, """Number of homonym name-strings where the nodes have species rank."""),
    'genus_homonym_count':
     (9, """Number of homonym name-strings where the nodes have genus rank."""),
    'max_depth':
     (10, """Maximum nesting depth of any node in the taxonomy."""),
    'max_children':
    (11, """Maximum number of children for any node in the taxonomy."""),
    'branching_factor':
    (20, """Branching factor (average number of children per internal node)."""),

    'absorbed':
     (70, """Record-keeping placeholders for source taxa that were absorbed into a larger taxon."""),
    'incertae_sedis_count':
     (72, """Number of nodes marked <em>incertae sedis</em> or equivalent."""),
    'extinct_count':
     (74, """Number of nodes annotated as being for an extinct taxon."""),
    'infraspecific_count':
     (76, """Number of nodes below the rank of species (e.g. subspecies, variety)."""),
    'barren':
     (78, """Number of nodes above the rank of species that subtend no node of rank species."""),
    'none of the above':
    (99, "UNCATEGORIZED")
}

alignment_label_info = {
    "same/curated":
    (01, """Alignment particularly established by a curator, usually to
            repair a mistake made by automatic alignment."""),
    "same/by-division-name":
    (03, """Aligned to separation taxonomy, to establish locations of separation taxa in the source taxonomy."""),
    "none":
    (05, """There were no candidates for this source taxon."""),
    "by-heuristic":
    (10, """A choice was made between two or more candidates using heuristics (for breakdown see below)."""),
    "confirmed":
    (30, """There was only a single candidate, and it was confirmed
            by a 'yes' answer from one of the heuristics."""),
    "by elimination":
    (32, """There was only a single candidate, and it was not confirmed by any
heuristic (the match involved a synonym)."""),
    "ambiguous tip":
    (36, """The heuristics were unable to choose from among multiple
candidates; no alignment is recorded for the source node, which is a tip."""),
    "ambiguous internal":
    (38, """The heuristics were unable to choose from among multiple
candidates; no alignment is recorded for the source node, which is internal."""),
    "rejected":
    (39, """Every candidate was rejected by a 'no' from one of the heuristics."""),
}

# names to agree with those in method-details.md

heuristic_label_info = {
    "disjoint divisions":    (10, 'Separation'),
    "disparate ranks":       (11, "Disparate ranks"),
    "by lineage":            (12, 'Lineage'),
    "overlapping membership":(14, 'Overlap'),
    "same-division-weak":    (16, 'Proximity'),
    "by name":               (18, 'Same name-string'),
}

merge_label_info = {
    "mapped/tip":
    (66, """Source node (a tip) is aligned to a workspace node.  No action, except that the 
source's extinctness flag, if any, is copied to the workspace node."""), #was aligned/tip
    "mapped/internal":
    (68, """Similarly, internal node"""), #was aligned/internal

    "new/graft":
    (70, """Root of unaligned source subtree copied (grafted) to existing workspace node."""),

    "new/in-graft":
    (70, """Part of an unaligned source subtree copied to workspace."""),

    # "graft/tip":
    # (71, """Source tip internal to a graft."""),
    # "graft/polysemy":
    # (72, """Similarly, but there is already another node with this name-string in the workspace."""),
    # "graft/internal":
    # (74, """Internal node internal to a graft."""),

    "new/refinement":
    (76, 'Source node inserted into the hierarchy above one workspace node and below another.'),
    "reject/absorbed":
    (80, 'Source node absorbed into larger workspace taxon; no conflict with classification.'),
    "reject/inconsistent":
    (82, 'Source node absorbed into larger workspace taxon; conflicts with classification.'),
    "ambiguous/redundant":
    (86, 'Ambiguous source node, not aligned and not merged.')
}

all_keys = {}
for i in [metrics_label_info, heuristic_label_info, alignment_label_info, merge_label_info]:
    for key in i:
        all_keys[key] = True

def sort_key(label):
    return label_info.get(label, label)

# Single argument is directory containing the 4 json/csv summary files.
# Output goes to stdout.

if __name__ == '__main__':
    format_report(sys.argv[1])
